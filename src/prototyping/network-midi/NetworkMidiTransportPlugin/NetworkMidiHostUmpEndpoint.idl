// These are WinRT because that's closer to COM than what I started with
// To be plugins to the service, these will need to change to COM DLLs
// so they can be discovered and dynamically loaded. WinRT can't be
// loaded in the same way.

import "MidiMessageBuffer.idl";

namespace Windows.Devices.Midi.NetworkMidiTransportPlugin
{
    [default_interface]
    runtimeclass NetworkMidiHostUmpEndpoint // : Windows.Devices.Midi.ServiceContracts.IMidiUmpEndpoint
    {
        NetworkMidiHostUmpEndpoint();

        // TODO: These need to be whatever buffer Gary has implemented
        // and they may be assigned in the constructor, not necessarily 
        // exposed in this way. This is prototype code only
        
        // MIDI In
        Windows.Devices.Midi.NetworkMidiTransportPlugin.MidiMessageBuffer IncomingMidiMessages {get; };

        
        // MIDI Out
        Windows.Devices.Midi.NetworkMidiTransportPlugin.MidiMessageBuffer OutgoingMidiMessages {get; };

        // TBD: do we need to break these out into a DeviceInformation-type class like 
        // Windows.Devices.Enumeration does today?
        String Id { get; };
        Windows.Foundation.Collections.PropertySet Properties { get; };


        // TODO: properties to hold the port, hostaddress, other properties, etc.
        // Also, may want to differentiate between host and client endpoints? 
        // Or just have a Role field? Most code will be similar, but order of ops
        // is different as are the parameters




        // Not members of the UmpEndpoint interface contract. Just specific to Network impl
        // used by the factory which creates these endpoints. Derived from the json properties
        Windows.Foundation.IAsyncAction StartAsync(String hostName, String port, String midiEndpointName, String midiProductInstanceId, Boolean advertise, String serviceInstanceName);

    }
}

